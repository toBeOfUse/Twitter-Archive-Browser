<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ArchiveAccess.APIDoc API documentation</title>
<meta name="description" content="API Documentation
‚Ä¶" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ArchiveAccess.APIDoc</code></h1>
</header>
<section id="section-intro">
<h1 id="api-documentation">API Documentation</h1>
<p>All API requests must contain an Authorization cookie obtained from /api/authenticate. All query string parameters are required unless otherwise indicated. Page numbers start at 1. The standard way to display a user's name is "display name (@handle) | nickname if it exists".</p>
<h2 id="messagelikes">Messagelikes</h2>
<p>Messagelikes, represented here as objects that inherit from <code><a title="ArchiveAccess.DBRead.MessageLike" href="DBRead.html#ArchiveAccess.DBRead.MessageLike">MessageLike</a></code>, represent pieces of information that fit naturally in the flow of a conversation, including regular messages. Because messagelikes in any given conversation tend to reference the same users over and over again, it would be highly redundant for each of them to contain nested user objects; instead, they simply contain user ids, and when they are requested from the API, the top-level JSON object that is returned contains a "results" array and a "users" array, containing the requested serialized MessageLike objects and serialized <code><a title="ArchiveAccess.DBRead.ArchivedUserSummary" href="DBRead.html#ArchiveAccess.DBRead.ArchivedUserSummary">ArchivedUserSummary</a></code> objects, respectively.</p>
<h2 id="authorization">Authorization</h2>
<h3 id="get-apigetpasswordconversation_id"><code>GET /api/getpassword/:conversation_id</code></h3>
<p>Asks the server for a randomly generated password that will grant access to a specific conversation, which can be placed in sharable links to conversations and messages. The response type will be text/plain. This endpoint can only be used by users who were authenticated via the master password.</p>
<h3 id="post-apiauthenticate"><code>POST /api/authenticate</code></h3>
<p>The body of this request should contain a password in plain text; an Authorization cookie will be set by the response (which has no body) which will enable future API requests to succeed. The password can either be the master password or one generated for a specific conversation by /api/getpassword/:conversation_id.</p>
<h2 id="getset-conversations-data">Get/Set Conversations Data</h2>
<p>These endpoints return up to 20 serialized <code><a title="ArchiveAccess.DBRead.Conversation" href="DBRead.html#ArchiveAccess.DBRead.Conversation">Conversation</a></code> objects.</p>
<h3 id="get-apiconversationsfirstoldestnewestmostusedmostusedbymepage123includegroupindividual"><code>GET /api/conversations?first=[oldest|newest|mostused|mostusedbyme]&amp;page=[1|2|3|...]&amp;include=[group,individual]</code></h3>
<p>Gets conversations sorted by time. If you specify first=oldest, the conversations with the oldest first message will be returned first; if you specify first=newest, the conversations with the most recent last message will be returned first; the other options sort by the number of messages or the number of messages sent by you (descending.) The include parameter should be a comma-delimited list of the conversation types ("group" and "individual") that will be included in the results.</p>
<h3 id="get-apiconversationswithuseriduser_id"><code>GET /api/conversations/withuser?id=[user_id]</code></h3>
<p>Gets the conversations that a specific user has appeared in, ordered by the number of messages they sent in that conversation in descending order.</p>
<h3 id="get-apiconversationidconversation_id"><code>GET /api/conversation?id=[conversation_id]</code></h3>
<p>Gets the database record for a specific conversation.</p>
<h3 id="get-apiconversationsnamesconversationconversation_idfirstoldestnewestpage123"><code>GET /api/conversations/names?conversation=[conversation_id]&amp;first=[oldest|newest]&amp;page=[1|2|3...]</code></h3>
<p>Gets all the names that a (group) conversation has ever had, sorted according to the <code>first</code> parameter. (Individual conversations cannot have custom names üôÅ.) Each page contains up to 50 serialized <code><a title="ArchiveAccess.DBRead.NameUpdate" href="DBRead.html#ArchiveAccess.DBRead.NameUpdate">NameUpdate</a></code> objects. Because name updates are messagelikes, they are enclosed in a "results" array and accompanied by a "users" array in the returned JSON object.</p>
<h3 id="post-apiconversationsnotesidconversation_id"><code>POST /api/conversations/notes?id=[conversation_id]</code></h3>
<p>Sets a conversation's "notes" field in the database to the plain text in the body of this request. This endpoint can only be used by clients who were authenticated via the master password.</p>
<h2 id="get-messages">Get Messages</h2>
<h3 id="get-apimessages"><code>GET /api/messages?</code></h3>
<p>Filter clause (optional): <code>conversation=[conversation_id]|byuser=[user_id]</code></p>
<p>Timezone clause: <code>after=[timestamp]|before=[timestamp]|at=[timestamp]</code></p>
<p>Search clause (optional): <code>search=[query]</code></p>
<p>The main endpoint for obtaining messages from the API. This endpoint's payload includes all messagelike objects; in other words, any that inherit from <code><a title="ArchiveAccess.DBRead.MessageLike" href="DBRead.html#ArchiveAccess.DBRead.MessageLike">MessageLike</a></code>. You can tell which type each object has by looking at the "schema" field in the serialized result, which contains the name of the original object's class. This endpoint returns 40 normal messages at a time; the name update and joining and leaving events are additional to that. Message/event objects are always sorted oldest to newest (ascending.)</p>
<p>Note that the html_contents field in normal messages contains links presented as HTML \<a> tags.</p>
<p>The filter clause is fairly self explanatory; pick either a conversation= or a byuser= parameter to send in. If it is omitted, any and all messages can come through, and if displayed to an end user, conversation events will need to be presented with their conversation name to make things clear.</p>
<p>The timezone clause's first two options can be either "beginning" or "end" respectively, to retrieve messages from the very beginning or very end of the conversation; the "at" option will return the 20 messages from immediately before the timestamp and 20 messages after; if a message was sent at that exact timestamp, it will count as being before it. Events are included if they happened after the given timestamp but before the 40th message if the first option is used and vice versa for the second; for the third, only events that happened after the first returned message and before the last returned message are included. Don't overthink the logic of retrieving a complete set of messages and events as you move in either direction in time; if you want to retrieve messages from before the ones you currently have loaded, just use the before option with the oldest timestamp you have in the messages and events you have; if you want to populate messages from after, use the after option with the newest timestamp you have.</p>
<p>The search clause allows you to further filter message results by their contents. It takes a URL-encoded string containing words that will be searched for individually and quotation mark-surrounded phrases that will be searched for as a unit. Words that are searched for individually will use a "stemmed" index so that searches for "walk" will also match "walking", for example.</p>
<h3 id="get-apimessageidmessage_id"><code>GET /api/message?id=[message_id]</code></h3>
<p>Gets the database record for a specific message; the message will still be contained in a "results" array alongside a "users" array.</p>
<h3 id="get-apimediaconversation_idmessage_idfilename"><code>GET /api/media/[conversation_id]/[message_id]/[filename]</code></h3>
<p>Retrieves a media item from the thing.</p>
<h2 id="getset-user-data">Get/Set User Data</h2>
<p>User objects contain the same data as their database records (documented here \&lt;sql_schema>) except that IDs are strings to make the data JavaScript-safe and the "avatar" and "avatar_extension" fields are replaced with a single "avatar_url" one (that corresponds to the avatar-retrieving endpoint below.) If a conversation query parameter is specified, user objects are joined with the participant record that links them to that conversation, which adds messages_sent, start_time, and end_time fields.</p>
<h3 id="get-apiusersconversationconversation_idpage123"><code>GET /api/users?conversation=[conversation_id]&amp;page=[1|2|3|...]</code></h3>
<p>Retrieves an array of users sorted by the number of messages that they have sent. The conversation parameter is optional; if it's supplied, only users with messages in the specified conversation will be returned and they'll be ordered by the number of messages they sent in that conversation.</p>
<h3 id="get-apiuseriduser_id"><code>GET /api/user?id=[user_id]</code></h3>
<p>Gets the database record for a specific user.</p>
<h3 id="get-apiuserspresentconversationconversation_idtimetimestamp"><code>GET /api/userspresent?conversation=[conversation_id]&amp;time=[timestamp]</code></h3>
<p>Retrieves an array of users that were known to be present in a certain conversation at a certain time. This may be missing users that were added at the very beginning of a conversation that you created if they never gave any sign of their presence by sending a message or updating the conversation name or leaving; this information is simply left out of Twitter archives for unknown reasons.</p>
<h3 id="get-apiavataruser_idoptional_file_extension"><code>GET /api/avatar/[user_id][.optional_file_extension]</code></h3>
<p>Retrieves a user's avatar as an image file. The exact type of image file will be specified in the Content-Type header and can also be part of the url (although that is Optional; the correct file will be returned regardless.)</p>
<h3 id="post-apiusersnicknameiduser_id"><code>POST /api/users/nickname?id=[user_id]</code></h3>
<p>Sets the nickname field in the database for a user to the plain text in the body of this request. Nicknames have a character limit of 50 characters. Can only be used by users authenticated with the master password.</p>
<h3 id="post-apiusersnotesiduser_id"><code>POST /api/users/notes?id=[user_id]</code></h3>
<p>Sets the notes field for this user to the plain text in the body of this request. This endpoint can only be used by clients who were authenticated via the master password.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
API Documentation
=================

All API requests must contain an Authorization cookie obtained from /api/authenticate. All query string parameters are required unless otherwise indicated. Page numbers start at 1. The standard way to display a user&#39;s name is &#34;display name (@handle) | nickname if it exists&#34;.

Messagelikes
------------

Messagelikes, represented here as objects that inherit from `ArchiveAccess.DBRead.MessageLike`, represent pieces of information that fit naturally in the flow of a conversation, including regular messages. Because messagelikes in any given conversation tend to reference the same users over and over again, it would be highly redundant for each of them to contain nested user objects; instead, they simply contain user ids, and when they are requested from the API, the top-level JSON object that is returned contains a &#34;results&#34; array and a &#34;users&#34; array, containing the requested serialized MessageLike objects and serialized `ArchiveAccess.DBRead.ArchivedUserSummary` objects, respectively.

Authorization
-------------

### `GET /api/getpassword/:conversation_id`

Asks the server for a randomly generated password that will grant access to a specific conversation, which can be placed in sharable links to conversations and messages. The response type will be text/plain. This endpoint can only be used by users who were authenticated via the master password.

### `POST /api/authenticate`

The body of this request should contain a password in plain text; an Authorization cookie will be set by the response (which has no body) which will enable future API requests to succeed. The password can either be the master password or one generated for a specific conversation by /api/getpassword/:conversation_id.

Get/Set Conversations Data
--------------------------

These endpoints return up to 20 serialized `ArchiveAccess.DBRead.Conversation` objects.

### `GET /api/conversations?first=[oldest|newest|mostused|mostusedbyme]&amp;page=[1|2|3|...]&amp;include=[group,individual]`

Gets conversations sorted by time. If you specify first=oldest, the conversations with the oldest first message will be returned first; if you specify first=newest, the conversations with the most recent last message will be returned first; the other options sort by the number of messages or the number of messages sent by you (descending.) The include parameter should be a comma-delimited list of the conversation types (&#34;group&#34; and &#34;individual&#34;) that will be included in the results.

### `GET /api/conversations/withuser?id=[user_id]`

Gets the conversations that a specific user has appeared in, ordered by the number of messages they sent in that conversation in descending order.

### `GET /api/conversation?id=[conversation_id]`

Gets the database record for a specific conversation.

### `GET /api/conversations/names?conversation=[conversation_id]&amp;first=[oldest|newest]&amp;page=[1|2|3...]`

Gets all the names that a (group) conversation has ever had, sorted according to the `first` parameter. (Individual conversations cannot have custom names üôÅ.) Each page contains up to 50 serialized `ArchiveAccess.DBRead.NameUpdate` objects. Because name updates are messagelikes, they are enclosed in a &#34;results&#34; array and accompanied by a &#34;users&#34; array in the returned JSON object.

### `POST /api/conversations/notes?id=[conversation_id]`

Sets a conversation&#39;s &#34;notes&#34; field in the database to the plain text in the body of this request. This endpoint can only be used by clients who were authenticated via the master password.

Get Messages
------------

### `GET /api/messages?`

Filter clause (optional): `conversation=[conversation_id]|byuser=[user_id]`

Timezone clause: `after=[timestamp]|before=[timestamp]|at=[timestamp]`

Search clause (optional): `search=[query]`

The main endpoint for obtaining messages from the API. This endpoint&#39;s payload includes all messagelike objects; in other words, any that inherit from `ArchiveAccess.DBRead.MessageLike`. You can tell which type each object has by looking at the &#34;schema&#34; field in the serialized result, which contains the name of the original object&#39;s class. This endpoint returns 40 normal messages at a time; the name update and joining and leaving events are additional to that. Message/event objects are always sorted oldest to newest (ascending.)

Note that the html_contents field in normal messages contains links presented as HTML \&lt;a&gt; tags.

The filter clause is fairly self explanatory; pick either a conversation= or a byuser= parameter to send in. If it is omitted, any and all messages can come through, and if displayed to an end user, conversation events will need to be presented with their conversation name to make things clear.

The timezone clause&#39;s first two options can be either &#34;beginning&#34; or &#34;end&#34; respectively, to retrieve messages from the very beginning or very end of the conversation; the &#34;at&#34; option will return the 20 messages from immediately before the timestamp and 20 messages after; if a message was sent at that exact timestamp, it will count as being before it. Events are included if they happened after the given timestamp but before the 40th message if the first option is used and vice versa for the second; for the third, only events that happened after the first returned message and before the last returned message are included. Don&#39;t overthink the logic of retrieving a complete set of messages and events as you move in either direction in time; if you want to retrieve messages from before the ones you currently have loaded, just use the before option with the oldest timestamp you have in the messages and events you have; if you want to populate messages from after, use the after option with the newest timestamp you have.

The search clause allows you to further filter message results by their contents. It takes a URL-encoded string containing words that will be searched for individually and quotation mark-surrounded phrases that will be searched for as a unit. Words that are searched for individually will use a &#34;stemmed&#34; index so that searches for &#34;walk&#34; will also match &#34;walking&#34;, for example.

### `GET /api/message?id=[message_id]`

Gets the database record for a specific message; the message will still be contained in a &#34;results&#34; array alongside a &#34;users&#34; array.

### `GET /api/media/[conversation_id]/[message_id]/[filename]`

Retrieves a media item from the thing.

Get/Set User Data
-----------------

User objects contain the same data as their database records (documented here \&lt;sql_schema\&gt;) except that IDs are strings to make the data JavaScript-safe and the &#34;avatar&#34; and &#34;avatar_extension&#34; fields are replaced with a single &#34;avatar_url&#34; one (that corresponds to the avatar-retrieving endpoint below.) If a conversation query parameter is specified, user objects are joined with the participant record that links them to that conversation, which adds messages_sent, start_time, and end_time fields.

### `GET /api/users?conversation=[conversation_id]&amp;page=[1|2|3|...]`

Retrieves an array of users sorted by the number of messages that they have sent. The conversation parameter is optional; if it&#39;s supplied, only users with messages in the specified conversation will be returned and they&#39;ll be ordered by the number of messages they sent in that conversation.

### `GET /api/user?id=[user_id]`

Gets the database record for a specific user.

### `GET /api/userspresent?conversation=[conversation_id]&amp;time=[timestamp]`

Retrieves an array of users that were known to be present in a certain conversation at a certain time. This may be missing users that were added at the very beginning of a conversation that you created if they never gave any sign of their presence by sending a message or updating the conversation name or leaving; this information is simply left out of Twitter archives for unknown reasons.

### `GET /api/avatar/[user_id][.optional_file_extension]`

Retrieves a user&#39;s avatar as an image file. The exact type of image file will be specified in the Content-Type header and can also be part of the url (although that is Optional; the correct file will be returned regardless.)

### `POST /api/users/nickname?id=[user_id]`

Sets the nickname field in the database for a user to the plain text in the body of this request. Nicknames have a character limit of 50 characters. Can only be used by users authenticated with the master password.

### `POST /api/users/notes?id=[user_id]`

Sets the notes field for this user to the plain text in the body of this request. This endpoint can only be used by clients who were authenticated via the master password.

&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#api-documentation">API Documentation</a><ul>
<li><a href="#messagelikes">Messagelikes</a></li>
<li><a href="#authorization">Authorization</a><ul>
<li><a href="#get-apigetpasswordconversation_id">GET /api/getpassword/:conversation_id</a></li>
<li><a href="#post-apiauthenticate">POST /api/authenticate</a></li>
</ul>
</li>
<li><a href="#getset-conversations-data">Get/Set Conversations Data</a><ul>
<li><a href="#get-apiconversationsfirstoldestnewestmostusedmostusedbymepage123includegroupindividual">GET /api/conversations?first=[oldest|newest|mostused|mostusedbyme]&amp;page=[1|2|3|&hellip;]&amp;include=[group,individual]</a></li>
<li><a href="#get-apiconversationswithuseriduser_id">GET /api/conversations/withuser?id=[user_id]</a></li>
<li><a href="#get-apiconversationidconversation_id">GET /api/conversation?id=[conversation_id]</a></li>
<li><a href="#get-apiconversationsnamesconversationconversation_idfirstoldestnewestpage123">GET /api/conversations/names?conversation=[conversation_id]&amp;first=[oldest|newest]&amp;page=[1|2|3&hellip;]</a></li>
<li><a href="#post-apiconversationsnotesidconversation_id">POST /api/conversations/notes?id=[conversation_id]</a></li>
</ul>
</li>
<li><a href="#get-messages">Get Messages</a><ul>
<li><a href="#get-apimessages">GET /api/messages?</a></li>
<li><a href="#get-apimessageidmessage_id">GET /api/message?id=[message_id]</a></li>
<li><a href="#get-apimediaconversation_idmessage_idfilename">GET /api/media/[conversation_id]/[message_id]/[filename]</a></li>
</ul>
</li>
<li><a href="#getset-user-data">Get/Set User Data</a><ul>
<li><a href="#get-apiusersconversationconversation_idpage123">GET /api/users?conversation=[conversation_id]&amp;page=[1|2|3|&hellip;]</a></li>
<li><a href="#get-apiuseriduser_id">GET /api/user?id=[user_id]</a></li>
<li><a href="#get-apiuserspresentconversationconversation_idtimetimestamp">GET /api/userspresent?conversation=[conversation_id]&amp;time=[timestamp]</a></li>
<li><a href="#get-apiavataruser_idoptional_file_extension">GET /api/avatar/[user_id][.optional_file_extension]</a></li>
<li><a href="#post-apiusersnicknameiduser_id">POST /api/users/nickname?id=[user_id]</a></li>
<li><a href="#post-apiusersnotesiduser_id">POST /api/users/notes?id=[user_id]</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ArchiveAccess" href="index.html">ArchiveAccess</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>