<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ArchiveAccess.JSONStream API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ArchiveAccess.JSONStream</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ijson
from pprint import pprint
from pathlib import Path


class PrefixedJSON:
    &#34;&#34;&#34;takes a .js file that assigns some json-formatted data to a global variable
    (like the twitter archive .js files do) and skips past the assignment so that the
    file can be used as pure json. compatible with the json and ijson modules.

    Attributes:
        filename: name/path of the file we&#39;re using.

    How to use:
        &gt;&gt;&gt; with PrefixedJSON(&#34;file.js&#34;) as json_file:
        ...     parser = ijson.parse(json_file)
    &#34;&#34;&#34;

    def __init__(self, file):
        self.filename = file

    def __enter__(self):
        &#34;&#34;&#34;prepares a file to be read as json.

        opens a file in bytes mode (for ijson compatibility/optimization purposes),
        reads data from it until it finds a character that can act as the start of
        some json data, then seeks backwards one byte so that that character is the
        next one that will be read.

        Returns:
            a prepared file object.
        &#34;&#34;&#34;
        self.file = open(self.filename, &#34;rb&#34;)
        byte = self.file.read(1)
        while byte != bytes(&#34;[&#34;, encoding=&#34;utf-8&#34;) and byte != bytes(
            &#34;{&#34;, encoding=&#34;utf-8&#34;
        ):
            byte = self.file.read(1)
        self.file.seek(-1, 1)
        return self.file

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.file.close()


class MessageStream:
    &#34;&#34;&#34;turns twitter archive .js files containing dms into an iterable stream of
    messages and other conversation events.

    returns messageCreate and other channel event objects for either a group dm or
    individual dm .js file with the small modification of placing the conversation ids
    and event names in each event dict instead of having them outside (in the
    &#34;conversationId&#34; and &#34;type&#34; fields respectively). uses the ijson module to avoid
    loading the whole .js file into memory.

    Attributes:
        path: path to .js file that the messages are being obtained from
        ijson_events_processed: an ijson event is raised when ijson finds some data
            in the code; the number of processed events here serves as a progress
            indicator. ijson events are not to be confused with conversation events like
            messageCreate or the other ones this class yields, which contain a lot more
            data.
        ijson_events_total: the total number of ijson events reading this file will
            cause.

    How to use:
        &gt;&gt;&gt; for message in MessageStream(&#34;messages.js&#34;):
        ...     save_in_database(message)
    &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;initializes the object and does a quick pre-count of how many ijson events
        we will have to process.

        Args:
            path: path to the .js file this object will glean conversation events from.
        &#34;&#34;&#34;
        self.path = path
        self.ijson_events_processed = 0
        self.ijson_events_total = 0
        with PrefixedJSON(self.path) as temp:
            for _ in ijson.parse(temp):
                self.ijson_events_total += 1

    @property
    def percentage(self):
        &#34;simplest way to see how much of the current file has been read&#34;
        return self.ijson_events_processed / self.ijson_events_total * 100

    def __iter__(self):
        &#34;&#34;&#34;gathers ijson events and yields dicts representing conversation events as
        they emerge.

        conversation events can be of the types messageCreate, joinConversation,
        participantsJoin, participantsLeave, or conversationNameUpdate; this method
        grabs each object representing one of these events, adds &#39;type&#39; and
        &#39;conversationId&#39; fields to them based on context from elsewhere in the json
        data, and yields them.
        &#34;&#34;&#34;
        with PrefixedJSON(self.path) as json_file:
            conversation_id = &#34;&#34;
            in_message = False
            message = {}
            current_dict = message

            event_types = [
                &#34;messageCreate&#34;,
                &#34;joinConversation&#34;,
                &#34;participantsJoin&#34;,
                &#34;participantsLeave&#34;,
                &#34;conversationNameUpdate&#34;,
            ]

            for prefix, event, value in ijson.parse(json_file):
                if prefix == &#34;item.dmConversation.conversationId&#34;:
                    conversation_id = value
                if prefix.startswith(
                    tuple(
                        &#34;item.dmConversation.messages.item.&#34; + x + &#34;.&#34;
                        for x in event_types
                    )
                ):
                    key = prefix.split(&#34;.&#34;)[-1]
                    in_message = True
                    message[&#34;type&#34;] = prefix.split(&#34;.&#34;)[4]
                    if event == &#34;start_array&#34;:
                        message[key] = []
                    elif event == &#34;start_map&#34;:
                        array_name = prefix.split(&#34;.&#34;)[-2]
                        message[array_name].append({})
                        current_dict = message[array_name][-1]
                    elif event == &#34;end_map&#34;:
                        current_dict = message
                    elif event in [
                        &#34;string&#34;,
                        &#34;null&#34;,
                        &#34;boolean&#34;,
                        &#34;integer&#34;,
                        &#34;double&#34;,
                        &#34;number&#34;,
                    ]:
                        if key == &#34;item&#34;:
                            array_name = prefix.split(&#34;.&#34;)[-2]
                            message[array_name].append(value)
                        else:
                            current_dict[key] = value
                elif prefix == &#34;item.dmConversation.messages.item&#34; and in_message:
                    message[&#34;conversationId&#34;] = conversation_id
                    yield message
                    message = {}
                    current_dict = message
                    in_message = False
                self.ijson_events_processed += 1


def prefix_finder(path):  # pragma: no cover
    &#34;returns all the prefixes ijson finds in a file; used for parser development&#34;
    with PrefixedJSON(path) as json_file:
        prefixes = set()
        for p, _, _ in ijson.parse(json_file):
            prefixes.add(p)
    return prefixes


def dump(path):  # pragma: no cover
    &#34;&#34;&#34;prints all the data ijson finds in a file in ijson event form; Not Recommended
    for large files&#34;&#34;&#34;
    with PrefixedJSON(path) as json_file:
        for prefix, event, value in ijson.parse(json_file):
            print(&#34;prefix=&#34; + prefix + &#34;, event=&#34; + event + &#34;, value=&#34; + str(value))


def test(path):  # pragma: no cover
    &#34;&#34;&#34;shady test function that prints the dicts that the parser outputs for a given
    file for manual review&#34;&#34;&#34;
    for message in (s := MessageStream(path)) :
        pprint(message, width=200)


if __name__ == &#34;__main__&#34;:  # pragma: no cover
    print(&#34;------------ Individual DMs Test ------------&#34;)
    test(&#34;./testdata/individual_dms_test.js&#34;)
    print()
    print(&#34;------------ Group DMs Test ------------&#34;)
    test(&#34;./testdata/group_dms_test.js&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ArchiveAccess.JSONStream.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>prints all the data ijson finds in a file in ijson event form; Not Recommended
for large files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(path):  # pragma: no cover
    &#34;&#34;&#34;prints all the data ijson finds in a file in ijson event form; Not Recommended
    for large files&#34;&#34;&#34;
    with PrefixedJSON(path) as json_file:
        for prefix, event, value in ijson.parse(json_file):
            print(&#34;prefix=&#34; + prefix + &#34;, event=&#34; + event + &#34;, value=&#34; + str(value))</code></pre>
</details>
</dd>
<dt id="ArchiveAccess.JSONStream.prefix_finder"><code class="name flex">
<span>def <span class="ident">prefix_finder</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>returns all the prefixes ijson finds in a file; used for parser development</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prefix_finder(path):  # pragma: no cover
    &#34;returns all the prefixes ijson finds in a file; used for parser development&#34;
    with PrefixedJSON(path) as json_file:
        prefixes = set()
        for p, _, _ in ijson.parse(json_file):
            prefixes.add(p)
    return prefixes</code></pre>
</details>
</dd>
<dt id="ArchiveAccess.JSONStream.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>shady test function that prints the dicts that the parser outputs for a given
file for manual review</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(path):  # pragma: no cover
    &#34;&#34;&#34;shady test function that prints the dicts that the parser outputs for a given
    file for manual review&#34;&#34;&#34;
    for message in (s := MessageStream(path)) :
        pprint(message, width=200)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ArchiveAccess.JSONStream.MessageStream"><code class="flex name class">
<span>class <span class="ident">MessageStream</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>turns twitter archive .js files containing dms into an iterable stream of
messages and other conversation events.</p>
<p>returns messageCreate and other channel event objects for either a group dm or
individual dm .js file with the small modification of placing the conversation ids
and event names in each event dict instead of having them outside (in the
"conversationId" and "type" fields respectively). uses the ijson module to avoid
loading the whole .js file into memory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to .js file that the messages are being obtained from</dd>
<dt><strong><code>ijson_events_processed</code></strong></dt>
<dd>an ijson event is raised when ijson finds some data
in the code; the number of processed events here serves as a progress
indicator. ijson events are not to be confused with conversation events like
messageCreate or the other ones this class yields, which contain a lot more
data.</dd>
<dt><strong><code>ijson_events_total</code></strong></dt>
<dd>the total number of ijson events reading this file will
cause.</dd>
</dl>
<p>How to use:
&gt;&gt;&gt; for message in MessageStream("messages.js"):
&hellip;
save_in_database(message)</p>
<p>initializes the object and does a quick pre-count of how many ijson events
we will have to process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to the .js file this object will glean conversation events from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageStream:
    &#34;&#34;&#34;turns twitter archive .js files containing dms into an iterable stream of
    messages and other conversation events.

    returns messageCreate and other channel event objects for either a group dm or
    individual dm .js file with the small modification of placing the conversation ids
    and event names in each event dict instead of having them outside (in the
    &#34;conversationId&#34; and &#34;type&#34; fields respectively). uses the ijson module to avoid
    loading the whole .js file into memory.

    Attributes:
        path: path to .js file that the messages are being obtained from
        ijson_events_processed: an ijson event is raised when ijson finds some data
            in the code; the number of processed events here serves as a progress
            indicator. ijson events are not to be confused with conversation events like
            messageCreate or the other ones this class yields, which contain a lot more
            data.
        ijson_events_total: the total number of ijson events reading this file will
            cause.

    How to use:
        &gt;&gt;&gt; for message in MessageStream(&#34;messages.js&#34;):
        ...     save_in_database(message)
    &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;initializes the object and does a quick pre-count of how many ijson events
        we will have to process.

        Args:
            path: path to the .js file this object will glean conversation events from.
        &#34;&#34;&#34;
        self.path = path
        self.ijson_events_processed = 0
        self.ijson_events_total = 0
        with PrefixedJSON(self.path) as temp:
            for _ in ijson.parse(temp):
                self.ijson_events_total += 1

    @property
    def percentage(self):
        &#34;simplest way to see how much of the current file has been read&#34;
        return self.ijson_events_processed / self.ijson_events_total * 100

    def __iter__(self):
        &#34;&#34;&#34;gathers ijson events and yields dicts representing conversation events as
        they emerge.

        conversation events can be of the types messageCreate, joinConversation,
        participantsJoin, participantsLeave, or conversationNameUpdate; this method
        grabs each object representing one of these events, adds &#39;type&#39; and
        &#39;conversationId&#39; fields to them based on context from elsewhere in the json
        data, and yields them.
        &#34;&#34;&#34;
        with PrefixedJSON(self.path) as json_file:
            conversation_id = &#34;&#34;
            in_message = False
            message = {}
            current_dict = message

            event_types = [
                &#34;messageCreate&#34;,
                &#34;joinConversation&#34;,
                &#34;participantsJoin&#34;,
                &#34;participantsLeave&#34;,
                &#34;conversationNameUpdate&#34;,
            ]

            for prefix, event, value in ijson.parse(json_file):
                if prefix == &#34;item.dmConversation.conversationId&#34;:
                    conversation_id = value
                if prefix.startswith(
                    tuple(
                        &#34;item.dmConversation.messages.item.&#34; + x + &#34;.&#34;
                        for x in event_types
                    )
                ):
                    key = prefix.split(&#34;.&#34;)[-1]
                    in_message = True
                    message[&#34;type&#34;] = prefix.split(&#34;.&#34;)[4]
                    if event == &#34;start_array&#34;:
                        message[key] = []
                    elif event == &#34;start_map&#34;:
                        array_name = prefix.split(&#34;.&#34;)[-2]
                        message[array_name].append({})
                        current_dict = message[array_name][-1]
                    elif event == &#34;end_map&#34;:
                        current_dict = message
                    elif event in [
                        &#34;string&#34;,
                        &#34;null&#34;,
                        &#34;boolean&#34;,
                        &#34;integer&#34;,
                        &#34;double&#34;,
                        &#34;number&#34;,
                    ]:
                        if key == &#34;item&#34;:
                            array_name = prefix.split(&#34;.&#34;)[-2]
                            message[array_name].append(value)
                        else:
                            current_dict[key] = value
                elif prefix == &#34;item.dmConversation.messages.item&#34; and in_message:
                    message[&#34;conversationId&#34;] = conversation_id
                    yield message
                    message = {}
                    current_dict = message
                    in_message = False
                self.ijson_events_processed += 1</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ArchiveAccess.JSONStream.MessageStream.percentage"><code class="name">var <span class="ident">percentage</span></code></dt>
<dd>
<div class="desc"><p>simplest way to see how much of the current file has been read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def percentage(self):
    &#34;simplest way to see how much of the current file has been read&#34;
    return self.ijson_events_processed / self.ijson_events_total * 100</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ArchiveAccess.JSONStream.PrefixedJSON"><code class="flex name class">
<span>class <span class="ident">PrefixedJSON</span></span>
<span>(</span><span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>takes a .js file that assigns some json-formatted data to a global variable
(like the twitter archive .js files do) and skips past the assignment so that the
file can be used as pure json. compatible with the json and ijson modules.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>name/path of the file we're using.</dd>
</dl>
<p>How to use:
&gt;&gt;&gt; with PrefixedJSON("file.js") as json_file:
&hellip;
parser = ijson.parse(json_file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrefixedJSON:
    &#34;&#34;&#34;takes a .js file that assigns some json-formatted data to a global variable
    (like the twitter archive .js files do) and skips past the assignment so that the
    file can be used as pure json. compatible with the json and ijson modules.

    Attributes:
        filename: name/path of the file we&#39;re using.

    How to use:
        &gt;&gt;&gt; with PrefixedJSON(&#34;file.js&#34;) as json_file:
        ...     parser = ijson.parse(json_file)
    &#34;&#34;&#34;

    def __init__(self, file):
        self.filename = file

    def __enter__(self):
        &#34;&#34;&#34;prepares a file to be read as json.

        opens a file in bytes mode (for ijson compatibility/optimization purposes),
        reads data from it until it finds a character that can act as the start of
        some json data, then seeks backwards one byte so that that character is the
        next one that will be read.

        Returns:
            a prepared file object.
        &#34;&#34;&#34;
        self.file = open(self.filename, &#34;rb&#34;)
        byte = self.file.read(1)
        while byte != bytes(&#34;[&#34;, encoding=&#34;utf-8&#34;) and byte != bytes(
            &#34;{&#34;, encoding=&#34;utf-8&#34;
        ):
            byte = self.file.read(1)
        self.file.seek(-1, 1)
        return self.file

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.file.close()</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ArchiveAccess" href="index.html">ArchiveAccess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ArchiveAccess.JSONStream.dump" href="#ArchiveAccess.JSONStream.dump">dump</a></code></li>
<li><code><a title="ArchiveAccess.JSONStream.prefix_finder" href="#ArchiveAccess.JSONStream.prefix_finder">prefix_finder</a></code></li>
<li><code><a title="ArchiveAccess.JSONStream.test" href="#ArchiveAccess.JSONStream.test">test</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ArchiveAccess.JSONStream.MessageStream" href="#ArchiveAccess.JSONStream.MessageStream">MessageStream</a></code></h4>
<ul class="">
<li><code><a title="ArchiveAccess.JSONStream.MessageStream.percentage" href="#ArchiveAccess.JSONStream.MessageStream.percentage">percentage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ArchiveAccess.JSONStream.PrefixedJSON" href="#ArchiveAccess.JSONStream.PrefixedJSON">PrefixedJSON</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>